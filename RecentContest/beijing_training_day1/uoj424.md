# 【集训队作业2019】count

**题目链接：[424. count - Universal Online Judge](http://uoj.ac/problem/424)**

### 总体思路

通过适当的建模，将原问题转化为括号序列计数问题，从而使用组合数学相关知识解决

### 题解

显然，两个序列不同构，当且仅当它们的笛卡尔树不同。于是问题转化为了笛卡尔树计数，此外还要求根到任一叶子节点的路径向左走的次数不超过m

我们知道，n个点的完全二叉树可以与长为n-1的括号序列一一对应。即：左括号表示在当前点添加左儿子并走过去；右括号表示向上走找到第一个没有右儿子的点，给它添加右儿子并走过去

我们还知道，n个点的一般二叉树与2n+1个点的完全二叉树具有一一对应的关系。即：2n+1个点的完全二叉树去掉叶子就是n个点的一般二叉树，反之亦然

于是n个点的一般二叉树就与长为2n的括号序列建立起了一一对应关系。我们只要统计长为2n的括号序列数量即可，那个要求就可以转化为：任一前缀中，未匹配的左括号不超过m+1个

然后容斥就行了，代码和 [【XSY Round 1446】C.树](http://www.ebola.pro/article/solutions/xsyr1446_c) 几乎完全一样

```cpp
#include<bits/stdc++.h>
using namespace std;
 
const int ha=998244353;
const int N=20000010;
int fac[N],ifac[N],n,m;
 
int Pow(int a,int b)
{
    int ans=1;
    for(;b;b>>=1,a=1ll*a*a%ha)
        if(b&1) ans=1ll*ans*a%ha;
    return ans;
}
 
void Init(int n)
{
    fac[0]=1;
    for(int i=1;i<=n;i++)
        fac[i]=1ll*fac[i-1]*i%ha;
    ifac[n]=Pow(fac[n],ha-2);
    for(int i=n-1;i>=0;i--)
        ifac[i]=1ll*ifac[i+1]*(i+1)%ha;
}
 
inline int C(int n,int m){return n<m?0:1ll*fac[n]*ifac[m]%ha*ifac[n-m]%ha;}
 
int main()
{
    cin>>n>>m;
    if(n<m) return puts("0"),0;
    m+=2;Init(n<<1);
    long long ans=C(n<<1,n);
    for(int i=0;i<n;i+=m)
    {
        ans-=C(n<<1,n+i+1);
        ans-=C(n<<1,n+i+m-1);
        ans+=C(n<<1,n+i+m)<<1;
    }
    ans=(ans%ha+ha)%ha;
    cout<<ans<<endl;
    return 0;
}
```